AWSTemplateFormatVersion: '2010-09-09'

Description: ECS Cluster Application Service (rev:1)

Parameters:
  Name:
    Type: String
    Description: Name of this Application
    ConstraintDescription: Must be DNS friendly
    AllowedPattern: ^[a-zA-Z][a-zA-Z0-9\-]+$
  ClusterName:
    Type: String
    Description: Name of the ECS cluster to use
    ConstraintDescription: Must be DNS friendly
    AllowedPattern: ^[a-zA-Z][a-zA-Z0-9\-]+$
  HealthCheckPath:
    Description: Healthcheck Path used on TargetGroup
    Type: String
    Default: /
  HealthCheckTimeout:
    Description: The amount of time, in seconds, during which no response means a failed health check (2-120 seconds).
    Type: Number
    Default: 5
  HealthCheckInterval:
    Description: The approximate amount of time between health checks of an individual target (5-300 seconds).
    Type: Number
    Default: 10
  DeregistrationDelay:
    Description: Target Group Deregistration Delay timeout in seconds
    Type: Number
    Default: 30
  Autoscaling:
    Description: Enable Autoscaling
    Type: String
    Default: false
    AllowedValues:
      - true
      - false
  AutoscalingTargetValue:
    Description: Target CPU for Autoscaling
    Type: Number
    Default: 50
  AutoscalingMaxSize:
    Description: Max number of containers to autoscale
    Type: Number
    Default: 8
  AutoscalingMinSize:
    Description: Min number of containers to autoscale
    Type: Number
    Default: 2
  HostedZoneName:
    Type: String
    Description: Hosted Zone name for domain record created for this app
    Default: ""
  Hostname:
    Type: String
    Default: ""
  HostnameCreate:
    Type: String
    Default: "false"
  PathPattern:
    Type: String
    Default: "/*"
  LogRetentionDays:
    Type: Number
    Default: 90
  ColorLive:
    Type: String
    Default: Green
    AllowedValues:
      - Green
      - Blue

Conditions:
  isHostnameCreate: !Equals [ !Ref HostnameCreate, 'true' ]
  hasHostname: !Not [ !Equals [ !Ref Hostname, '' ] ]
  isAutoscaling: !Equals [ !Ref Autoscaling, 'true' ]
  isGreenLive: !Equals [ !Ref ColorLive, 'Green' ]

Resources:
  AlbTargetGroupGreen:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Name: !Sub "${ClusterName}-${Name}-G"
      HealthCheckIntervalSeconds: !Ref HealthCheckInterval
      HealthCheckPath: !Ref HealthCheckPath
      HealthCheckProtocol: HTTP
      HealthCheckTimeoutSeconds: !Ref HealthCheckTimeout
      HealthyThresholdCount: 2
      Port: 80
      Protocol: HTTP
      UnhealthyThresholdCount: 2
      TargetGroupAttributes:
        - Key: deregistration_delay.timeout_seconds
          Value: !Ref DeregistrationDelay
      VpcId:
        Fn::ImportValue: !Sub "TfExport-Ecs-${ClusterName}-VpcId"

  AlbTargetGroupBlue:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Name: !Sub "${ClusterName}-${Name}-B"
      HealthCheckIntervalSeconds: !Ref HealthCheckInterval
      HealthCheckPath: !Ref HealthCheckPath
      HealthCheckProtocol: HTTP
      HealthCheckTimeoutSeconds: !Ref HealthCheckTimeout
      HealthyThresholdCount: 2
      Port: 80
      Protocol: HTTP
      UnhealthyThresholdCount: 2
      TargetGroupAttributes:
        - Key: deregistration_delay.timeout_seconds
          Value: !Ref DeregistrationDelay
      VpcId:
        Fn::ImportValue: !Sub "TfExport-Ecs-${ClusterName}-VpcId"

  ListenerRuleLive:
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
    Properties:
      Actions:
        - Type: forward
          TargetGroupArn: !If
            - isGreenLive
            - Ref: AlbTargetGroupGreen
            - Ref: AlbTargetGroupBlue
      Conditions:
        - !If 
          - hasHostname
          - Field: host-header
            HostHeaderConfig:
              Values:
                - !Ref Hostname
          - !Ref AWS::NoValue
        - Field: path-pattern
          PathPatternConfig:
            Values:
              - !Ref PathPattern
      ListenerArn:
        Fn::ImportValue: !Sub "TfExport-Ecs-${ClusterName}-AlbListenerHttpsArn"
      Priority: !GetAtt AlbListernerPriority.Value

  ListenerRuleTest:
    Type: AWS::ElasticLoadBalancingV2::ListenerRule
    Properties:
      Actions:
        - Type: forward
          TargetGroupArn: !If
            - isGreenLive
            - Ref: AlbTargetGroupBlue
            - Ref: AlbTargetGroupGreen
      Conditions:
        - !If 
          - hasHostname
          - Field: host-header
            HostHeaderConfig:
              Values:
                - !Ref Hostname
          - !Ref AWS::NoValue
        - Field: path-pattern
          PathPatternConfig:
            Values:
              - !Ref PathPattern
      ListenerArn:
        Fn::ImportValue: !Sub "TfExport-Ecs-${ClusterName}-AlbListenerTestTrafficHttpsArn"
      Priority: !GetAtt AlbListernerTestTrafficPriority.Value

  EcsService:
    Type: AWS::ECS::Service
    Properties:
      ServiceName: !Sub "${Name}"
      DesiredCount: 1
      PlacementStrategies:
        - Type: spread
          Field: attribute:ecs.availability-zone
        - Type: binpack
          Field: memory
      DeploymentController:
        Type: EXTERNAL
      Cluster:
        Fn::ImportValue: !Sub "TfExport-Ecs-${ClusterName}-EcsName"

  ServiceScalingTarget:
    Type: AWS::ApplicationAutoScaling::ScalableTarget
    Condition: isAutoscaling
    Properties:
      RoleARN: !Sub "arn:aws:iam::${AWS::AccountId}:role/aws-service-role/ecs.application-autoscaling.amazonaws.com/AWSServiceRoleForApplicationAutoScaling_ECSService"
      MaxCapacity: !Ref AutoscalingMaxSize
      MinCapacity: !Ref AutoscalingMinSize
      ResourceId: !Sub
        - "service/${ECSCluster}/${ServiceName}"
        - ECSCluster:
            Fn::ImportValue: !Sub "TfExport-Ecs-${ClusterName}-EcsName"
          ServiceName: !GetAtt EcsService.Name
      ScalableDimension: ecs:service:DesiredCount
      ServiceNamespace: ecs

  ServiceScalingPolicy:
    Type: AWS::ApplicationAutoScaling::ScalingPolicy
    Condition: isAutoscaling
    Properties:
      PolicyName: !Sub '${AWS::StackName}-scale-target'
      PolicyType: TargetTrackingScaling
      ScalingTargetId: !Ref 'ServiceScalingTarget'
      TargetTrackingScalingPolicyConfiguration:
        TargetValue: !Ref AutoscalingTargetValue
        PredefinedMetricSpecification:
          PredefinedMetricType: ECSServiceAverageCPUUtilization

  Route53Hostname:
    Type: AWS::Route53::RecordSet
    Condition: isHostnameCreate
    Properties:
      Name: !Ref Hostname
      HostedZoneName: !Ref HostedZoneName
      Type: A
      AliasTarget:
        HostedZoneId:
          Fn::ImportValue: !Sub "TfExport-Ecs-${ClusterName}-AlbZoneId"
        DNSName:
          Fn::ImportValue: !Sub "TfExport-Ecs-${ClusterName}-AlbDnsName"

  LogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      RetentionInDays: !Ref LogRetentionDays
      LogGroupName: !Sub "/ecs/${ClusterName}/${Name}"

  AlbListernerPriority:
    Type: Custom::CustomCodeDeployDeploymentGroup
    Properties:
      ServiceToken: !GetAtt 'CustomResourceFunctionAlbPriority.Arn'
      AlbListenerArn:
        Fn::ImportValue: !Sub "TfExport-Ecs-${ClusterName}-AlbListenerHttpsArn"

  AlbListernerTestTrafficPriority:
    Type: Custom::CustomCodeDeployDeploymentGroup
    Properties:
      ServiceToken: !GetAtt 'CustomResourceFunctionAlbPriority.Arn'
      AlbListenerArn:
        Fn::ImportValue: !Sub "TfExport-Ecs-${ClusterName}-AlbListenerTestTrafficHttpsArn"

  CustomResourceFunctionAlbPriority:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.lambda_handler
      Timeout: 30
      Role: !GetAtt 'CustomResourceFunctionAlbPriorityRole.Arn'
      Runtime: python3.6
      Code:
        ZipFile: |
          import logging
          import boto3
          from botocore.vendored import requests
          import cfnresponse

          client = boto3.client('elbv2')
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def lambda_handler(event, context):
            logger.info('got event {}'.format(event))
            responseData = {}

            highestPriority = 1

            if event['RequestType'] == 'Create' or event['RequestType'] == 'Update':

              extraArgs = {
                'ListenerArn': event['ResourceProperties']['AlbListenerArn']
              }

              while True:
                response = client.describe_rules(**extraArgs)
                for rule in response['Rules']:
                  if rule['Priority'] == 'default':
                    continue
                  if int(rule['Priority']) > highestPriority:
                    highestPriority = int(rule['Priority'])

                if not 'NextMarker' in response:
                    break
                extraArgs['Marker'] = response['NextMarker']

              responseData = {
                'Value': str(highestPriority+1),
                'NextValue': str(highestPriority+2)
              }

            else:
              pass

            logger.info('event {}'.format(event))
            logger.info('responseData {}'.format(responseData))
            cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData, str(highestPriority+1))

  CustomResourceFunctionAlbPriorityRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - lambda.amazonaws.com
          Action:
          - sts:AssumeRole
      Path: "/"
      Policies:
      - PolicyName: root
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
            - logs:CreateLogGroup
            - logs:CreateLogStream
            - logs:PutLogEvents
            Resource: arn:aws:logs:*:*:*
          - Effect: Allow
            Action:
            - elasticloadbalancing:DescribeRules
            Resource: "*"

Outputs:
  ListenerRuleLive:
    Value: !Ref ListenerRuleLive
    Export:
      Name: !Sub "${AWS::StackName}-ListenerRuleLive"
  ListenerRuleTest:
    Value: !Ref ListenerRuleTest
    Export:
      Name: !Sub "${AWS::StackName}-ListenerRuleTest"
  AlbTargetGroupGreen:
    Value: !Ref AlbTargetGroupGreen
    Export:
      Name: !Sub "${AWS::StackName}-AlbTargetGroupGreen"
  AlbTargetGroupBlue:
    Value: !Ref AlbTargetGroupBlue
    Export:
      Name: !Sub "${AWS::StackName}-AlbTargetGroupBlue"
  AlbTargetGroupLive:
    Value: !If
      - isGreenLive
      - !Ref AlbTargetGroupGreen
      - !Ref AlbTargetGroupBlue
  AlbTargetGroupTest:
    Value: !If
      - isGreenLive
      - !Ref AlbTargetGroupBlue
      - !Ref AlbTargetGroupGreen
  ColorLive:
    Value: !If 
      - isGreenLive
      - Green
      - Blue
  ColorTest:
    Value: !If 
      - isGreenLive
      - Blue
      - Green
